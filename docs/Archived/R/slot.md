## 测试向量集是否相等

- 法 1：
```r
all(symbols) == symbols[1]
```

- 法 2：
```r
length(unique(symbols)) == 1 
```

- `symbols`：这是一个向量，可能是一个数值向量、字符向量、逻辑向量等。
    
- `unique(symbols)`：这部分代码通过 `unique()` 函数获取 `symbols` 向量中的唯一值。换句话说，它会去掉向量中的重复元素，只保留每个值的一个实例。
    
- `length(unique(symbols))`：这部分代码计算去重后的 `symbols` 向量的长度，也就是唯一值的个数。
    
- `== 1`：这是一个逻辑比较操作，用于检查前面计算得到的唯一值个数是否等于 1。如果等于 1，说明所有元素的值都是相同的；如果不等于 1，说明向量中存在不同的值。
    

所以，整个表达式 `length(unique(symbols)) == 1` 的含义是，判断向量 `symbols` 中的所有元素是否都具有相同的值。如果为真，说明向量中的元素值都相同；如果为假，说明向量中存在不同的值。

--- 

```r
same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]

```
 **`$$` 的作用和 `&` 和 `|`  类似，即如果前面的结果返回是 F 则不继续后一步比较**


#根据结果分配奖金额度
#可以一一建立映射关系
```r
payouts <- c ("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
            "B" = 10, "C"  = 10, "0" = 0)
```
 在取子集时，不想保留符号名称而只想得到中将金额，可以对输出结果运行 unname 函数

取子集方法 2：

例如，已知一个逻辑判断经过强制转换后求和后把数值储存在 cherries 这个对象中，每一个值取不同的返回值：

假设一个向量集，其中含有一个 C ，则返回值为 2，两个为 5，没有为 0

C 出现的次数储存在 cherries 中


```r
#建立向量
c(0, 2, 5)
#匹配返回值
c(0, 2, 5)[cherries]
	#由于R的索引是从1 开始，而cherries的取值范围是[0,3] ##3这个值已经在前面的条件控制语句中考虑了因此在这里的取值范围是[0,2]
	#而0的返回值是空的，所以解决方法是 cherries+1
c(0, 2, 5)[cherries+1]
	#这样就完成了
```